Domande:

1. debugger gives failure to stop MCU: "target is running, failed to stop the target" -> this went away for a while but then it came back once I reflashed STM
2. tag uart debugging - where can I see my_error_report_messages?
3. TAG FSM seems to be executed only once at the moment. 
   It also doesn't go to aci_hal_end_of_radio_activity_event nor it ever goes to tag_state = TX if OTAP == 1
   If OTAP == 0, it goes to TX only once 

it seems to get stuck waiting for I2C data from MCU

BLE_TXE_status

FLASHING BINARI

STM32 side: 

sotto SENSOR, DEBUG -> c'è il binario da flashare direttamente sulla STM32 
BFTAG01_STM32L031F4_PVD_SENSOR.bin

STM - stlink utility
0x08080000 -> indirizzo di memoria 
contriene in esadecimale: 14-> 20 secondi di wait, 06-> 6 numero beacon
Questo va fatto anche nella radio!!! 

BLE side:
Binario sta sotto ewarm -> release -> exe e c'è il bin, considerare solo versione TAG e BS.
0X1007C000 -> programmazione della flash della radio parte da questo indirizzo -> anche qui c'è 0001406

RICORDA: i due indirizzi di memoria devono contenere le stesse info su RTPS e NTB.
In questo modo posso cambiare questi due parametri senza riprogrammare tutto.

RIDURRE I CONSUMI DELLA TAG QUANDO E' in WAIT:

OTAP: base station può programmare la tag, che quindi quando è in wait sta in ascolto.
la tag mette i dati in flash quando riceve. Quando si accende, la radio guarda quel valore in flash: se lo vede non vuoto, allora lo passa al microcontrollore in I2C. 
Ad avvenuta trasmissione, il micro riporta a FFFFF la casella di flash della radio e fa update del valore di RTPS e NTB. 

RIDUZIONE CONSUMI LATO BLE: 
Lato radio: modifica di alcuni parametri di scan per messaggi dalla base station.
 ⁃ TAG_RX_TIMEOUT_TH porta da 10 a 1
 ⁃ Oppure commenta aci_gap_start_observation_proc, ma probabilmente si incazza. 
 ⁃ aci_gap_start_observation_proc(LE scan interval + LE scan window): mettere al minimo I due parametri

Altra cosa, migliore e molto probabilmente più efficace.
Lato MCU: ogni volta che sono in WAIT (20 sec), viene chiamato My_Enter_Stop_Mode_WFI();
Gli interrupt che mi possono far uscire dallo wait sono o quello proveniente dal timer 1 o quello proveniente dal PVD: 
HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI); // Device in Stop Mode and WFI from PVD and LPTIM1.
Il timer 1 è quello che mi conta i famosi 20 secondi di RTPS: per far uscire da questo interrupt prima, posso alzare il livello del PVD con: 
My_Set_PVD(PWR_PVDLEVEL_4, PWR_PVD_MODE_IT_RISING); // Set PVD to 4 with Interrupt for falling vdd
Questa riga di codice viene messa dopo ms == WAIT in my_While().

Un'altra cosa che posso provare a fare, poi, è allungare il RTPS, così c'è più tempo tra cicli di beacon.  

Si può testare anche con la cella solare: i picchetti del WAIT dovrebbero essere molto più piccoli

